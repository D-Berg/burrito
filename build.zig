////
// DO NOT EDIT THIS FILE
////

const std = @import("std");
const foilz = @import("src/archiver.zig");
const builtin = @import("builtin");

const log = std.log;

const Builder = std.build.Builder;
const CrossTarget = std.zig.CrossTarget;
const Mode = std.builtin.Mode;
const LibExeObjStep = std.build.LibExeObjStep;

var builder: *Builder = undefined;
var target: *const CrossTarget = undefined;

var wrapper_exe: *LibExeObjStep = undefined;

// Memory allocator
var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
var allocator = arena.allocator();

pub fn build(b: *Builder) !void {
    log.info("Zig is building an Elixir binary... âš¡", .{});

    builder = b;
    target = &builder.standardTargetOptions(.{});

    // Run build steps!
    _ = try run_archiver();
    _ = try build_wrapper();

    log.info("DONE ðŸš€", .{});
}

pub fn run_archiver() !void {
    log.info("Generating and compressing release payload... ðŸ“¦", .{});

    const release_path = try std.process.getEnvVarOwned(allocator, "__BURRITO_RELEASE_PATH");
    try foilz.pack_directory(release_path, "./payload.foilz");

    if (builtin.os.tag == .windows) {
        _ = builder.exec(&[_][]const u8{ "cmd", "/C", "xz -9ez --check=crc32 --stdout --keep payload.foilz > src/payload.foilz.xz" });
    } else {
        _ = builder.exec(&[_][]const u8{ "/bin/sh", "-c", "xz -9ez --check=crc32 --stdout --keep payload.foilz > src/payload.foilz.xz" });
    }
}

pub fn build_wrapper() !void {
    log.info("Building wrapper and embedding payload... ðŸŒ¯", .{});

    const release_name = try std.process.getEnvVarOwned(allocator, "__BURRITO_RELEASE_NAME");
    const plugin_path = std.process.getEnvVarOwned(allocator, "__BURRITO_PLUGIN_PATH") catch null;
    const is_prod = std.process.getEnvVarOwned(allocator, "__BURRITO_IS_PROD") catch "1";
    const musl_runtime_path = std.process.getEnvVarOwned(allocator, "__BURRITO_MUSL_RUNTIME_PATH") catch "";
    var opt_level = std.builtin.Mode.Debug;

    if (std.mem.eql(u8, is_prod, "1")) {
        opt_level = std.builtin.Mode.ReleaseSmall;
    }

    var file = try std.fs.cwd().openFile("payload.foilz", .{});
    defer file.close();
    const uncompressed_size = try file.getEndPos();

    wrapper_exe = builder.addExecutable(.{
        .name = release_name,
        // In this case the main source file is merely a path, however, in more
        // complicated build scripts, this could be a generated file.
        .root_source_file = .{ .path = "src/wrapper.zig" },
        .target = target.*,
        .optimize = opt_level,
    });

    const exe_options = builder.addOptions();
    wrapper_exe.addOptions("build_options", exe_options);

    exe_options.addOption([]const u8, "RELEASE_NAME", release_name);
    exe_options.addOption(u64, "UNCOMPRESSED_SIZE", uncompressed_size);

    exe_options.addOption(bool, "IS_PROD", std.mem.eql(u8, is_prod, "1"));
    exe_options.addOption([]const u8, "MUSL_RUNTIME_PATH", musl_runtime_path);

    if (target.isWindows()) {
        wrapper_exe.addIncludePath(.{ .path = "src/" });
    }

    // Link standard C libary to the wrapper
    wrapper_exe.linkSystemLibrary("c");

    if (plugin_path) |plugin| {
        log.info("Plugin found! {s} ðŸ”Œ", .{plugin});

        const plugin_module = builder.createModule(.{
            .source_file = .{ .path = plugin },
        });
        wrapper_exe.addModule("burrito_plugin", plugin_module);
    } else {
        const plugin_module = builder.createModule(.{
            .source_file = .{ .path = "_dummy_plugin.zig" },
        });
        wrapper_exe.addModule("burrito_plugin", plugin_module);
    }

    wrapper_exe.addIncludePath(.{ .path = "src/xz" });
    wrapper_exe.addCSourceFile(.{ .file = .{ .path = "src/xz/xz_crc32.c" }, .flags = &[0][]const u8{} });
    wrapper_exe.addCSourceFile(.{ .file = .{ .path = "src/xz/xz_dec_lzma2.c" }, .flags = &[0][]const u8{} });
    wrapper_exe.addCSourceFile(.{ .file = .{ .path = "src/xz/xz_dec_stream.c" }, .flags = &[0][]const u8{} });

    builder.installArtifact(wrapper_exe);

    // const run_cmd = wrapper_exe.run();
    // run_cmd.step.dependOn(builder.getInstallStep());

    // const run_step = builder.step("run", "Run the app");
    // run_step.dependOn(&run_cmd.step);
}
