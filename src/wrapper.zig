////
// DO NOT EDIT THIS FILE
////

const builtin = @import("builtin");
const build_options = @import("build_options");
const std = @import("std");
const json = std.json;
const log = std.log;
const fs = std.fs;

const Sha1 = std.crypto.hash.Sha1;
const Base64 = std.base64.url_safe_no_pad.Encoder;

// Foilz Archive Util
const foilz = @import("archiver.zig");

// Maint utils
const logger = @import("logger.zig");
const maint = @import("maintenance.zig");
const shutil = @import("shutil.zig");
const win_asni = @cImport(@cInclude("win_ansi_fix.h"));

// Install dir suffix
const install_suffix = ".tinfoil";

const plugin = @import("burrito_plugin");

const metadata = @import("metadata.zig");
const MetaStruct = metadata.MetaStruct;

// Payload
pub const FOILZ_PAYLOAD = @embedFile("../payload.foilz.gz");
pub const RELEASE_METADATA_JSON = @embedFile("../_metadata.json");

// Memory allocator
var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
var allocator = &arena.allocator;

pub fn main() anyerror!void {
    log.debug("Size of embedded payload is: {}", .{FOILZ_PAYLOAD.len});

    // If this is not a production build, we always want a clean install
    const wants_clean_install = !build_options.IS_PROD;

    const meta = metadata.parse(allocator, RELEASE_METADATA_JSON).?;

    const install_dir = (try get_install_dir(&meta))[0..];
    const metadata_path = try fs.path.join(allocator, &[_][]const u8{ install_dir, "_metadata.json" });

    log.debug("Install Directory: {s}", .{install_dir});
    log.debug("Metadata path: {s}", .{metadata_path});

    // Ensure the destination directory is created
    try std.fs.cwd().makePath(install_dir);

    // If the metadata file exists, don't install again
    var needs_install: bool = false;
    std.fs.accessAbsolute(metadata_path, .{}) catch |err| {
        if (err == error.FileNotFound) {
            needs_install = true;
        } else {
            log.crit("We failed to open the destination directory with an unexpected error: {s}", .{err});
            return;
        }
    };

    // Get argvs
    const args = try std.process.argsAlloc(allocator);
    const args_trimmed = args[1..];
    defer std.process.argsFree(allocator, args);
    const args_string = try std.mem.join(allocator, " ", args_trimmed);
    log.debug("Passing args string: {s}", .{args_string});

    // Execute plugin code
    plugin.burrito_plugin_entry(install_dir, RELEASE_METADATA_JSON);

    // If we need an install, install the payload onto the target machine
    if (needs_install or wants_clean_install) {
        try do_payload_install(install_dir, metadata_path);
    } else {
        log.debug("Skipping archive unpacking, this machine already has the app installed!", .{});
    }

    // Check for maintenance commands
    if (args_trimmed.len > 0 and std.mem.eql(u8, args_trimmed[0], "maintenance")) {
        try logger.info("Entering burrito maintenance mode...", .{});
        try logger.info("Build metadata: {s}", .{RELEASE_METADATA_JSON});
        try maint.do_maint(args_trimmed[1..], install_dir);
        return;
    }

    // Clean up older versions
    const base_install_path = try get_base_install_dir();
    try maint.do_clean_old_versions(base_install_path, install_dir);

    // Get Env
    var env_map = try std.process.getEnvMap(allocator);

    // Add _IS_TTY env variable
    if (shutil.is_tty()) {
        try env_map.put("_IS_TTY", "1");
    } else {
        try env_map.put("_IS_TTY", "0");
    }

    // Get name of the exe (useful to pass into argv for the child erlang process)
    const exe_path = try fs.selfExePathAlloc(allocator);
    const exe_name = fs.path.basename(exe_path);

    // Compute the full base bin path
    const base_bin_path = try fs.path.join(allocator, &[_][]const u8{ install_dir, "bin", build_options.RELEASE_NAME });

    log.debug("Base Executable Path: {s}", .{base_bin_path});

    // Windows does not have a REAL execve, so instead the wrapper will hang around while the Erlang process runs
    // We'll use a ChildProcess with stdin and out being inherited
    if (builtin.os.tag == .windows) {
        // Fix up Windows 10+ consoles having ANSI escape support, but only if we set some flags
        win_asni.enable_virtual_term();

        const bat_path = try std.mem.concat(allocator, u8, &[_][]const u8{ base_bin_path, ".bat" });

        const win_args = &[_][]const u8{ bat_path, "start", exe_name };
        const final_args = try std.mem.concat(allocator, []const u8, &.{ win_args, args_trimmed });

        const win_child_proc = try std.ChildProcess.init(final_args, allocator);
        win_child_proc.env_map = &env_map;
        win_child_proc.stdout_behavior = .Inherit;
        win_child_proc.stdin_behavior = .Inherit;

        log.debug("CLI List: {s}", .{final_args});

        _ = try win_child_proc.spawnAndWait();
    } else {
        const cli = &[_][]const u8{ base_bin_path, "start", exe_name, args_string };
        log.debug("CLI List: {s}", .{cli});
        return std.process.execve(allocator, cli, &env_map);
    }
}

fn do_payload_install(install_dir: []const u8, metadata_path: []const u8) !void {
    // Unpack the files
    try foilz.unpack_files(FOILZ_PAYLOAD, install_dir);

    // Write metadata file
    const file = try fs.createFileAbsolute(metadata_path, .{ .truncate = true });
    try file.writeAll(RELEASE_METADATA_JSON);
}

fn get_base_install_dir() ![]u8 {
    return try fs.getAppDataDir(allocator, install_suffix);
}

fn get_install_dir(meta: *const MetaStruct) ![]u8 {
    // Combine the hash of the payload and a base dir to get a safe install directory
    const base_install_path = try get_base_install_dir();

    // Parse the ERTS version and app version from the metadata JSON string
    const dir_name = try std.fmt.allocPrint(allocator, "{s}_erts-{s}_{s}", .{ build_options.RELEASE_NAME, meta.erts_version, meta.app_version });

    // Ensure that base directory is created
    std.os.mkdir(base_install_path, 0o755) catch {};

    // Construct the full app install path
    const name = try fs.path.join(allocator, &[_][]const u8{ install_suffix, dir_name });
    return fs.getAppDataDir(allocator, name);
}
