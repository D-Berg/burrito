
# Burrito 🌯
### An Experimental Method For Elixir Command Line Application Distribution

* [What Is It?](#what-is-it)
  * [Background](#background)
  * [Feature Overview](#feature-overview)
  * [Technical Component Overview](#technical-component-overview)
  * [End-To-End Overview](#end-to-end-overview)
* [Quick Start](#quick-start)
  * [Experimental Disclaimer](#experimental-disclaimer)
  * [Preparation and Requirements](#preparation-and-requirements)
  * [Mix Project Setup](#mix-project-setup)
  * [Mix Release Config Options](#mix-release-config-options)
  * [Build-Time Environment Variables](#build-time-environment-variables)
  * [Application Entry Point](#application-entry-point)
* [Known Limitations and Issues](#known-limitations-and-issues)
  * [Runtime Requirements](#runtime-requirements)
  * [Libc Support](#libc-support)
* [Contributing](#contributing)
  * [Welcome!](#welcome-)

## What Is It?

#### Background
Burrito is an answer to an internal distribution problem we had, we needed to be able to run Elixir based CLI applications on Windows, MacOS, and Linux, in environments where we couldn't assume the Erlang runtime would be available, as well as locations where we did not have permission to install it using traditional methods.

Essentially we wanted to ship around small, single binary executables of our applications. We also wanted to be able to cross-compile these binaries from a common Linux CI system.

We were heavily inspired by [Bakeware](https://github.com/bake-bake-bake/bakeware) which laid a lot of the ground work. Ultimately we re-implemented our own solution in [Zig](https://ziglang.org/).

#### Feature Overview
* Compiles a self-extracting, self-running, executable of your Elixir application targeted to Windows, MacOS, or Linux
  * This package will contain your compiled BEAM code and the ERTS required to run the application itself.
* Attempts to re-compile [elixir-make](https://github.com/elixir-lang/elixir_make) based NIFs
* Provides a "plugin" interface where you can write a custom Zig function to run on start-up of your wrapped application.
* WIP - a few helper modules to aid in application update checks (see `lib/versions/release_file.ex` for details)

#### Technical Component Overview
Burrito is composed of a few different components:
* **Mix Release Module** - A module that is executed during the Mix release phase. This module takes care of packing up the files, downloading and copying in different ERTS runtimes, and launching the Zig Archiver and Wrapper.
* **Zig Archiver** - A small Zig library that packs up an entire directory into a tar-like blob. This is known as the "payload" -- which will contain all the compiled BEAM code of your release, and the ERTS for the target platform. This is Gzip compressed and then embedded directly into the wrapper program.
* **Zig Wrapper** - This is portable cross-platform Zig code that wraps around the payload generated during the Mix release process.

```
      Burrito Produced Binary
┌────────────────────────────────┐
│                                │
│       Zig Wrapper Binary       │ <---- Compiled from `wrapper.zig`
│                                │
├────────────────────────────────┤
│        Payload Archive         │
│ ┌────────────────────────────┐ │
│ │                            │ │
│ │    ERTS Native Binaries    │ <------ If cross-compiling, this is downloaded from a build server
│ │                            │ │
│ └────────────────────────────┘ │
│                                │ <---- This bottom payload portion is generated by `archiver.zig`
│ ┌────────────────────────────┐ │
│ │                            │ │
│ │   Application BEAM Code    │ │
│ │                            │ │
│ └────────────────────────────┘ │
│                                │
└────────────────────────────────┘
```

#### End To End Overview

 1. You build a Burrito wrapped binary of your application and send it to an end-user.
 2. The end-user launches your binary like any other native application on their system.
 3. In the background (first-run only) the payload is extracted into a well defined location on the system. (AppData, Application Support, etc.)
 4. The wrapper executes the Erlang runtime in the background, and launches your application within the same process, so it appears to be transparent to end-users.
 5. Subsequent runs of the same application and version will use the already extracted payload on their system unless it is uninstalled. 

## Quick Start
#### Experimental Disclaimer 
Burrito was initially built with our specific use-cases in mind, and a lot of this is heavily experimental and prototype quality code. We will happily accept community contributions to improve the usefulness and reliability of Burrito. 

#### Preparation and Requirements

**NOTE:** We currently only support building from MacOS and Linux machines. Due to the in-development nature of Zig, some targets cannot compile to other targets. Use this build matrix chart below to understand what you can and cannot build to and from:

|Target| Host | Host | Host | Host |
|--|--|--|--|--|
| | Windows x64 | Linux | MacOS (x86_64) | MacOS (Apple Silicon)** |
| Windows x64 |❌|✅|✅|❌|
| Linux |❌|✅|✅|❌| 
| MacOS (x86_64) |❌|⚠️*|✅|❌|
| MacOS (Apple Silicon)** |❌|❌|❌|❌|

\* elixir-make based NIFs cannot be cross-compiled from Linux to MacOS due to a currently missing linker feature in Zig's new linker (zld).

** We currently do not have access to an Apple Silicon machine to test Burrito on, both for build and runtime environments. It's possible that Rosetta can execute the x86_64 MacOS binaries, however we have not tested this. In addition, our Erlang build server does not have Apple Silicon builds due to [Github Actions lacking support for it](https://github.com/actions/virtual-environments/issues/2187).

----

You must have the following installed and in your PATH:

* Zig (master/nightly - we do not support 0.8.0) -- `zig`
* Gzip -- `gzip`
* 7z -- `7z`
* GNU Patch -- `patch`

----

#### Mix Project Setup

1. Install Burrito using the standard `mix.exs` methods.
2. Create a `releases` function in your `mix.exs`, add and configure the following for your project:

```elixir
  def releases do
  [
    example_cli_app: [
      steps: [:assemble, &Burrito.wrap/1],
      burrito: [
        targets: [:darwin, :win64, :linux],
        debug: Mix.env() != :prod,
        plugin: "./test_plugin/plugin.zig",
        no_clean: false,
      ]
    ]
  ]
  end
```

(See the Mix Release Config Options section for more info on these options!)

3. To execute a release for all the platformed defined in your `mix.exs` file: `MIX_ENV=prod mix release`
4. You can also override the target platforms using the `BURRITO_TARGET` environment variable
  * To execute a release for Windows: `MIX_ENV=prod BURRITO_TARGET=win64 mix release`
  * To execute a release for MacOS: `MIX_ENV=prod BURRITO_TARGET=darwin mix release`
  * To execute a release for Linux: `MIX_ENV=prod BURRITO_TARGET=linux mix release`

Non-production builds (any release created without `MIX_ENV` being set to `prod`) will produce a binary what will ALWAYS extract its payload, even if the application was already unpacked on the runtime machine. This helps speed up iteration of the same application version during development.

#### Mix Release Config Options

* `targets` - A list of atoms, the targets you want to build for (`:darwin`, `:win64`, `:linux`) whenever you run a `mix release` command -- if not defined, defaults to native host platform only.
* `debug` - Boolean, will produce a debug build if set to true. (Default: `false`)
* `no_clean` - Boolean, will not clean up after building if set to true. (Default: `false`)
* `plugin` - String, a path to a Zig file that contains a function `burrito_plugin_entry()` which will be called before unpacking the payload at runtime. See the example application in the repo for more information.

#### Build-Time Environment Variables

* `BURRITO_TARGET` - Override the list of targets provided in your `mix.exs` file using this environment variable. (ex: `BURRITO_TARGET=win64`, `BURRITO_TARGET=linux,darwin`)

#### Application Entry Point
For Burrito to work properly you must define a `:mod` in your project's Mix config:
```elixir
  def application do
    [
      mod: {MyEntryModule, []}
    ]
  end
```
This module must implement the callbacks defined by the [`Application`](https://hexdocs.pm/elixir/1.12/Application.html) module, as stated in the Mix documentation:

```elixir
defmodule MyEntryModule do
  def start(_, _) do
   # You can return a tuple of type {:ok, pid} if you want to keep the application running
   # Otherwise use System.halt(exit_code) to terminate the VM whenever you like
  end
end

```

If you wish you retrieve the argv passed to your program use this snippet:
```elixir
 args = :init.get_plain_arguments() |> Enum.map(&to_string/1)
 ```

## Known Limitations and Issues
#### Runtime Requirements
We tried to ensure the requirements for running the packaged up binaries were as slim as possible. These are the requirements for each runtime platform:
##### Windows
* MSVC Runtime for the Erlang version you are shipping
* Windows 10 Build 1511 or later (for ANSI color support)
##### Linux
* Any distribution with glibc
* libncurses-5 
##### MacOS
* No special requirements, however, please be aware of Gatekeeper and Codesign requirements for distribution

#### Libc Support
For Linux builds, we currently only produce glibc linked binaries. We have plans to add support for [musl-libc](https://www.musl-libc.org/) in the future!

## Contributing
#### Welcome!
We are happy to review and accept pull requests to improve Burrito.

We ask that you follow the established code formatting present in the repo.

Everything in this repo is licensed under The MIT License, see `LICENSE` for the full license text.